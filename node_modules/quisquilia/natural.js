/*jslint node: true */
"use strict";

var natural	= require('natural');
var util	= require('util');

var map_classifier = [];
var type_classifier = [];


exports.getMap = function(phrase)
{
	var map = "";
	var tokenizer = new natural.WordTokenizer();
	var words = tokenizer.tokenize(phrase)

	map_classifier.forEach(function(m)
	{
		words.forEach(function(w)
		{
			if(natural.JaroWinklerDistance(w,m[0]) > 0.9)
			{
				map = m[1];
			}
		});
	});

	return map;
};

exports.getType = function(phrase)
{
	var type = "";
	var tokenizer = new natural.WordTokenizer();
	var words = tokenizer.tokenize(phrase)

	type_classifier.forEach(function(m)
	{
		words.forEach(function(w)
		{
			if(natural.JaroWinklerDistance(w,m[0]) > 0.9)
			{
				type = m[1];
			}
		});
	});

	return type;
};

/**
 * Trains the classifier. Used on initialization
 * @param  {[type]} db [description]
 * @return {[type]}    [description]
 */
exports.train = function()
{

	/**
	 * Available Maps
	 * @type {natural}
	 * Qui metti le mappe, la prima stringa è quella che scrivono la seconda è quella a cui corrisponde.
	 * Se devi usare il carattere ' devi scrivere \'
	 */

	map_classifier.push(["summoner\'s rift","Summoner\'s Rift"]);
	map_classifier.push(["summoners rift","Summoner\'s Rift"]);
	map_classifier.push(["sr","Summoner\'s Rift"]);
	map_classifier.push(["SR","Summoner\'s Rift"]);
	map_classifier.push(["rift","Summoner\'s Rift"]);
	map_classifier.push(["summoner","Summoner\'s Rift"]);
	map_classifier.push(["twisted treeline","Twisted Treeline"]);
	map_classifier.push(["tt","Twisted Treeline"]);
	map_classifier.push(["TT","Twisted Treeline"]);
	map_classifier.push(["3v3","Twisted Treeline"]);
	map_classifier.push(["3vs3","Twisted Treeline"]);
	map_classifier.push(["3 v 3","Twisted Treeline"]);
	map_classifier.push(["3 vs 3","Twisted Treeline"]);
	map_classifier.push(["aram","ARAM"]);
	map_classifier.push(["HA","ARAM"]);
	map_classifier.push(["Howling Abyss","ARAM"]);
	map_classifier.push(["dom","Dominion"]);
	map_classifier.push(["dominion","Dominion"]);

	/**
	 * Available game types
	 * @type {natural}
	 */
	type_classifier.push(["blind","blind"]);
	type_classifier.push(["bl","blind"]);
	type_classifier.push(["BL","blind"]);
	type_classifier.push(["draft","draft"]);
	type_classifier.push(["dr","draft"]);
	type_classifier.push(["DR","draft"]);
	type_classifier.push(["custom","custom"]);
	type_classifier.push(["inhouse","inhouse"]);
	
	util.log("Classifier trained.");
}
