/*jslint node: true */
"use strict";

var consts			= require('./consts');
var util			= require('util');
var crypto          = require('crypto');
var db 				= require('quisquilia/db');
var helper 			= require('quisquilia/helper');
var q_natural 		= require('quisquilia/natural');

/**
 * Let's init the classifier
 */
q_natural.train();

// only 1 game at a time for now
global.game_id = 0;

exports.process = function (message, conference, from, xmpp, rtmp, callback)
{

	// if it's a server message we'll ignore it
	if(from == undefined) return;

	// return on my messages
	if(from == "sum50775006@pvp.net" || from == "quisquilia") return;
	if(from == "sum27039554@pvp.net" || from == "Zen Bot") return;

	if(from.indexOf("@pvp.net") >= 0)
	{
		db.getName(from, function(name)
		{
			from = name;
		});
	}

	var groupchat = false;
	var to;
	if(conference != null) groupchat = true;
	if(groupchat) to = conference;
	else to = from;

	/**
	 * If in the phrase i catch at least 2 of the 3 following flags it means it's a new game
	 * @type {Boolean}
	 */
	var isSpot = false;
	var isType = false;
	var isMap = false;
	var gameCounter = 0;

	var game_spots = 0;
	var game_type = "";
	var game_map = "";

	var args = [];

	/**
	 * Check for spots
	 * @type {RegExp}
	 */
	//var number_reg = "/0-9]+";
	game_spots = message.match(/\d+/g); 
	if(game_spots > 0 && game_spots <= 9) 
	{
		gameCounter++;
		isSpot = true;
	}

	/**
	 * Check for maps
	 */
	game_map = q_natural.getMap(message);
	if(game_map != "")
	{
		gameCounter++;
		isMap = true;
	}
	
	/**
	 * Check for type
	 * @type {[type]}
	 */
	game_type = q_natural.getType(message);
	if(game_type != "")
	{
		gameCounter++;
		isType = true;
	}

	// do we need to update a current game?
	var gameUpdated = false;
	db.getGame(conference, from, function(game_id)
	{
		if(game_id != null)
		{
			if(isSpot && !isMap && !isType) db.updateSpots(game_id, game_spots);
		}
	})

	if(gameCounter >= 2 && conference != null)
	{
		if(!isSpot) game_spots = "4";
		if(!isMap) game_map = "Summoner's Rift";
		if(!isType) game_type = "Blind"
		//var message = "Game Detected: Spots " + game_spots + " Map " + game_map + " type " + game_type;
		//callback(to, message, groupchat);
		

		// are there already active games with my nick?
		db.getGame(conference, from, function(game_id)
		{
			if(game_id === null)
			{
				db.addGame(conference, from, game_map, game_type, parseInt(game_spots));
			}
			else
			{
				//callback(to,"Sorry " + from + ", you have already an active game going on.",groupchat)
			}
		});		
	}
	else
	{
		// Check if it's a command (it must start with !)
		if(message.indexOf('!') === 0)
		{
			// create the args
			message = message.substring(1);
			args = message.split(" ");

			var command = args.shift();
			switch(command)
			{
				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				// Send the help (in private)
				case consts.COMMAND_HELP:

					var helpMessage = consts.COMMAND_HELP_DESCRIPTION;
					if(args.length > 0)
					{
						switch(args[0])
						{
							case consts.COMMAND_JOIN:
								helpMessage = consts.COMMAND_JOIN_DESCRIPTION;
								break;		
							case consts.COMMAND_LEAVE:
								helpMessage = consts.COMMAND_LEAVE_DESCRIPTION;
								break;
							case consts.COMMAND_CANCEL:
								helpMessage = consts.COMMAND_CANCEL_DESCRIPTION;
								break;
							case consts.COMMAND_LIST:
								helpMessage = consts.COMMAND_LIST_DESCRIPTION;
								break;
							case consts.COMMAND_SEEN:
								helpMessage = consts.COMMAND_SEEN_DESCRIPTION;
								break;
							case consts.COMMAND_GLOBAL:
								helpMessage = consts.COMMAND_GLOBAL_DESCRIPTION;
								break;
							case consts.COMMAND_INV:
								helpMessage = consts.COMMAND_INV_DESCRIPTION;
								break;
							case consts.COMMAND_STATS:
								helpMessage = consts.COMMAND_STATS_DESCRIPTION;
								break;
						}
					}
				
					// Send the normal message
					//callback(to, helpMessage, groupchat);	
					if(groupchat)
					{
						db.getAccount(from, function(account){
							xmpp.subscribe(account);
							callback(account, helpMessage, false);
						});
					}
					else
					{
						callback(to, helpMessage, false);
					}

					// also if the user is an admin send him in private the admin commands
					/*if(helper.isAdmin(from))
					{
						var helpMessage = consts.COMMAND_HELP_ADMIN_DESCRIPTION;
						//callback(from, helpMessage, false);	
					}*/


					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// General Stats
				case consts.COMMAND_STATS:
			
					db.getStats(function(stats)
					{
						stats = consts.TABLE_NEWLINE + consts.TABLE_HEADER + "Succesfully started games: " + stats;
						if(groupchat)
						{
							db.getAccount(from, function(account)
							{
								xmpp.subscribe(account);
								callback(account, stats, false);
							});
						}
						else
						{
							callback(to, stats, false);
						}
					});
					
					
					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// Joins a channel
				case consts.COMMAND_JOIN:
			
					if(helper.isAdmin(from))
					{
						if(args.length >= 1)
						{
							var channel = args.join(' ');
							var shasum = crypto.createHash('sha1');
							shasum.update(channel);
							channel = "pu~" + shasum.digest('hex') + "@lvl.pvp.net";
							db.joinConference(channel, args.join(' '), function()
							{						
								xmpp.join(channel);
							});
						
						}
						else
						{
							// Params not valid
							callback(to, consts.COMMAND_JOIN + " params not valid. Use !" + consts.COMMAND_HELP + " " + consts.COMMAND_JOIN, groupchat);
						}
					}
					
					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// Leaves a channel
				case consts.COMMAND_LEAVE:
			
					if(helper.isAdmin(from))
					{
						var channel = conference;
						if(args.length > 0) 
						{	
							channel = args.join(' ');
							var shasum = crypto.createHash('sha1');
							shasum.update(channel);
							channel = "pu~" + shasum.digest('hex') +  "@lvl.pvp.net";
						}

						db.partConference(channel, function()
						{
							xmpp.part(channel);
						});
					}
					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// List the active channels
				case consts.COMMAND_CHANNELS:
			
					if(helper.isAdmin(from))
					{
						var channel = conference;
						if(args.length > 0) 
						{	
							channel = args.join(' ');
							var shasum = crypto.createHash('sha1');
							shasum.update(channel);
							channel = "pu~" + shasum.digest('hex') +  "@lvl.pvp.net";
						}

						db.getActiveConferences(function(list)
						{
							if(groupchat)
							{
								list = consts.TABLE_NEWLINE + consts.TABLE_HEADER + "Active Channels\n\n" + list;
								db.getAccount(from, function(account)
								{
									xmpp.subscribe(account);
									callback(account, list, false);
								});
							}
							else
							{
								callback(to, list, false);
							}
						});
					}
					break;




				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// Check if user is admin
				case consts.COMMAND_ADMIN:

					var message;
					if(helper.isAdmin(from)) message = "Yes " + from + ", you are an admin.";
					else message = "No " + from + ", you aren't an admin.";
					callback(to, message, groupchat);
					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// Create a game
				/// the user tells the name of the map and the number of spots. Everytime someone join the spots are decreased
				/// When all the spots are filled the creator receives a message with the nick name he has to invite
				/// The creator can cancel a game, all the current players get a notification
				/// game can be blind, ranked, co-op, aram 
				/// args:
				/// !game map type spots 
				case consts.COMMAND_CREATEGAME:

					if(args.length >= 3)
					{
						// are there already active games with my nick?
						db.getGame(conference, from, function(game_id)
						{
							if(game_id === null)
							{
								//callback(to,"" + from + " you can create a game.",groupchat)	
								var map = args[0];
								var type = args[1];
								var spots = args[2];
								var message = "map: " + map + " | type: " + type + " | spots: " + spots;
								callback(to,message,groupchat);

								db.addGame(conference, from, map, type, spots);
							}
							else
							{
								callback(to,"Sorry " + from + ", you have already an active game going on.",groupchat)
							}
						});
					}
					else
					{
						// Params not valid
						callback(to, consts.COMMAND_CREATEGAME + " params not valid. Use !" + consts.COMMAND_HELP + " " + consts.COMMAND_CREATEGAME, groupchat);
					}

					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				// Cancel the current active game for user
				case consts.COMMAND_CANCELGAME:
					db.cancelGame(conference, from);
					break;


				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// List active games
				/// if someone ask the list the bot also check if the player is in game or not but querying the roster. 
				/// if the creator of the game is playing it means that game is not available anymore
				/// List is one line with the creator name and the partecipants with their rank (if any)
				/// Summoner Right [+3] An Average Buu (Silver) - Estop Revolt (Silver) 
				/// ARAM [+4] An Average Buu (Silver)
				/// Summoner Right [+2] An Average Buu (Silver) - Estop Revolt (Silver) 
				case consts.COMMAND_LISTGAMES:
					
					db.getGlobal(from, function(global)
					{
						// if it's a private message it's always global
						if(!groupchat) global = 1;
						else global = 0; // else it's always private, TODO: remove the global from settings

						db.getAllActiveGames(conference, global, function(list)
						{
							if(list === "")
							{
								list = consts.TABLE_NEWLINE + consts.TABLE_HEADER + "No games available. Why don't you create one instead?" + consts.TABLE_FOOTER;
							}
							else
							{
								list = consts.TABLE_NEWLINE + consts.TABLE_HEADER + list;
							}

							if(groupchat)
							{
								db.getAccount(from, function(account)
								{
									xmpp.subscribe(account);
									callback(account, list, false);
								});
							}
							else
							{
								callback(to, list, false);
							}
						});
					});
	
					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// Join a game
				/// join the selected game, if there are spots left
				/// the user can cancel, using the same command for canceling a game 
				/// in the roster if a player is in game all his games are canceled
				case consts.COMMAND_JOINGAME:
					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// Tells when the user was last seen on the channel
				case consts.COMMAND_SEEN:

					var player = args.join(' ');
					db.getSeen(conference,player, function(message)
					{
						if(groupchat)
						{
							db.getAccount(from, function(account){
								xmpp.subscribe(account);
								callback(account, message, false);
							});
						}
						else
						{
							callback(to, message, false);
						}
					});
					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// Tells when the user was last seen on the channel
				case consts.COMMAND_GLOBAL:

					//console.log("Global cmd from " + from);

					db.getGlobal(from, function(global)
					{
						if(global!=null)
						{
							if(global == 1) 
							{
								global = 0;
								var message = "You will only see games created in the chatroom you typed the command in.";
							}
							else
							{
								global = 1;
								var message = "You will see all the available games.";
							}

							db.setGlobal(from, global);

							if(groupchat)
							{
								db.getAccount(from, function(account)
								{
									xmpp.subscribe(account);
									callback(account, message, false);
								});
							}
							else
							{
								callback(to, message, false);
							}

							/*db.getAccount(from, function(account)
							{
								xmpp.subscribe(account);
								callback(account, message, false);
							});*/
						}
					});
					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// Ask for an invite
				case consts.COMMAND_INV:
					if(args.length == 1)
					{
						var game_id = args[0];
						db.getGameDetails(game_id, function(game)
						{
							if(game!=null)
							{
								// To the creator
								db.getAccount(game.creator, function(account)
								{
									var message = from + " requested an invite.";	
									xmpp.subscribe(account);
									callback(account, message, false);
								});

								// To the player
								db.getAccount(from, function(account)
								{
									var message = "A request was sent to " + game.creator;	
									xmpp.subscribe(account);
									callback(account, message, false);
								});
							}
							else
							{
								db.getAccount(from, function(account)
								{
									var message = "A game with id " + game_id + " wasn't found.";	
									xmpp.subscribe(account);
									callback(account, message, false);
								});
							}
						});
					}
					else
					{
						db.getAccount(from, function(account)
						{
							var message = "Command not valid : " + consts.COMMAND_INV_DESCRIPTION;	
							xmpp.subscribe(account);
							callback(account, message, false);
						});
					}

					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// Tells when the user was last seen on the channel
				/// 
				/*
				case consts.COMMAND_INHOUSE:

					console.log(global.game_id);

					if(global.game_id == 0)
					{

						var gameName = args.join(' ');
						rtmp.doCreateGame(gameName, function(err, result) 
						{
							global.game_id = result.object.id.value;
							callback(to, "Game " + gameName + " created", groupchat);

							// Invite who created the game
							rtmp.getSummonerByName(from, function(err, result)
							{
	  							var sum_id = result.object.summonerId.value;
	  							rtmp.doInvite(sum_id, function(err, result) {});
							});
							
							setTimeout(function()
	            			{
	              				rtmp.PlayerToObserver(global.game_id, function(err, result)
	          					{
	            					return console.log(util.inspect(result, false, null, true));
	          					});
	            			}, 15000);
	 					});
					}
					else
					{
						callback(to, "I'm already hosting a game, sorry.", groupchat);
					}
					break;

				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				/// Tells when the user was last seen on the channel
				case consts.COMMAND_INVITEME:

					console.log(global.game_id);

					if(global.game_id == 0)
					{
						callback(to, "There aren't any InHouse games up", groupchat);
					}
					else
					{
						rtmp.getSummonerByName(from, function(err, result)
						{
  							var sum_id = result.object.summonerId.value;
  							rtmp.doInvite(sum_id, function(err, result) {});
						});
					}
					break;
				*/

			}
		}
	}
};